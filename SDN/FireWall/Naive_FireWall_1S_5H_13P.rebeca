{"payload":{"allShortcutsEnabled":true,"fileTree":{"SDN":{"items":[{"name":"FireWall","path":"SDN/FireWall","contentType":"directory"},{"name":"Naive_FireWall_1S_5H_13P.property","path":"SDN/Naive_FireWall_1S_5H_13P.property","contentType":"file"},{"name":"Naive_FireWall_1S_5H_13P.rebeca","path":"SDN/Naive_FireWall_1S_5H_13P.rebeca","contentType":"file"}],"totalCount":3},"":{"items":[{"name":"SDN","path":"SDN","contentType":"directory"},{"name":"LICENSE","path":"LICENSE","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"}],"totalCount":3}},"fileTreeProcessingTime":4.570777,"foldersToFetch":[],"reducedMotionEnabled":"system","repo":{"id":639463940,"defaultBranch":"main","name":"Rebeca","ownerLogin":"h-zeynali","currentUserCanPush":true,"isFork":false,"isEmpty":false,"createdAt":"2023-05-11T17:27:32.000+03:30","ownerAvatar":"https://avatars.githubusercontent.com/u/40805031?v=4","public":true,"private":false},"refInfo":{"name":"main","listCacheKey":"v0:1683813452.0","canEdit":true,"refType":"branch","currentOid":"d97c68364dd0464a5e28caf33d90c3c0910c1a85"},"path":"SDN/Naive_FireWall_1S_5H_13P.rebeca","currentUser":{"id":40805031,"login":"h-zeynali","userEmail":"zeynali@gmail.com"},"blob":{"rawBlob":"\n \nreactiveclass Controller(16) { \n\tknownrebecs \n\t{\n\t\tSwitch s1;\n\t}\n\tstatevars \n\t{  \t\n\t\tbyte [10] seenDestIp; //Arraye for saving Ip of Hosts that be distination of packet from trusted zoon\n\t\tbyte seenDestIpIndx;// for remember index of  last inserted seenDestIp \n\t}\n\tController() {\n\t\t//We can Implement one of below function in sitation related to controller\n\t\t//self.initRoutings();\n\t\t//self.ExpressRoutingIsGonaChange() after(1);\n\t\t//self.changeRouting()after(2);\n\t\t\n\t\t\n\t\t//initialing SeenDestIp \n\t\tint i; \n     \tfor (i = 0; i < 10; i = i + 1) {\n     \t\tseenDestIp[i] \t= 0;\n     \t} \n     \tseenDestIpIndx = 0 ;\n\n\t}\n\n\tboolean AddToSeenDestination(byte DestIp)\n\t{\n\t\tif (seenDestIpIndx < 10 )\n\t\t{\n\t\t\tseenDestIp[seenDestIpIndx] = DestIp;\n\t\t\tseenDestIpIndx++;// = seenDestIpIndx + 1;\n\t\t\treturn true;\t\t\n\t\t}\n\t\telse \n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t}\n\t\n\tboolean isSeenDestination(byte DestIp)\n\t{\n\t\tint i ;\n\t\tfor (i = 0; i < 10; i = i + 1) \n\t\t{\n\t\t\tif (seenDestIp[i] == DestIp )\n\t\t\t{\n\t\t\t\treturn true;\t\t\n\t\t\t}\n\t\t}\n\t\treturn false;\n\n\t}\n\t\n\tmsgsrv initRoutings(){\n\t\t//init routing rules\n\t\t//modifyState(headerID, port, action , protocol) ; \n\t\t//action: 1 for drop 0 for forward \n\t\t//protocol: 1 for SSH 0 for Normal\n\t\t\n\t\t//s1.modifyState(10,1,0,1) after(1);\n\t\t//s1.modifyState(10,1,1,0);\n\n\t}\n\n\t\n\tmsgsrv ExpressRoutingIsGonaChange()\n\t{\n\t\ts1.changeRouting();\n\n\t}\n\t\n\tmsgsrv changeRouting(){\n\t\t//init routing rules\n\t\t//s1.modifyState(10,2,0,1) after(3); //Drop SSH protocol by IPId = 10 on port 2\n\t\t//s1.modifyState(10,2,1,0); //forward Other protocols by IpId = 10 on port 2\n\n\t}\n   \n\tmsgsrv newPacketInMessage(byte switchId, byte packetSrcId , byte packetDestId, byte packetData, byte packetProtocol, byte SwitchPort){\n\t\t// This message is sent from a switch to the controller when the switch processes a packet\n\t\t// for which it has no action rule to apply.  \n\t\tif (switchId == 1) //routing process related to switch 1\n\t\t{\n\t\t\tif (SwitchPort == 1 )// if packet arrive from trusted zoon\n\t\t\t{\n\t\t\t\t//forward packet by action = 0 \n\t\t\t\ts1.newPacketOutMessage(packetSrcId, packetDestId, packetData ,packetProtocol,SwitchPort, 0 );\n\t\t\t\t// add destination to seen destination\n\t\t\t\tAddToSeenDestination(packetDestId);\n\t\t\t\t\n\t\t\t}\n\t\t\telse if (SwitchPort == 2) // if packet arrive from untrusted zoon\n\t\t\t{\n\t\t\t\t// forward if source seen as a destination then forward because this packet is response\n\t\t\t\tif (isSeenDestination(packetSrcId))\n\t\t\t\t\ts1.newPacketOutMessage(packetSrcId, packetDestId, packetData ,packetProtocol,SwitchPort, 0 );\n\t\t\t\telse // drop if source is not seen yet and this is request from untrusted hosts \n\t\t\t\t\ts1.newPacketOutMessage(packetSrcId, packetDestId, packetData ,packetProtocol,SwitchPort, 1 );\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nreactiveclass Switch(20) { \n\tknownrebecs {\n\t\tController controller;\n\t} \n   \n\tstatevars {\n\t\tbyte SwId;\n\t\tboolean illegalAccess;\n\t\tboolean sshProtocolError;\n\t\tbyte [10] flowTableHeaderDestIP;\n\t\tbyte [10] flowTableHeaderSrcIP;\n\t\tbyte [10] flowTableHeaderProtocol;\n\t\tbyte [10] flowTableOutPort;\n\t\tbyte [10] flowTableActionType;\n\t\tbyte [10] flowTablePrioriry; //can be a list- future work\n\t\t//\n\t\tbyte [5] SwitchPort_isConnectedto; // 0 for disconnect, 1 for host, 2 for otherSwitch \n\t\tbyte [5] SwitchPort_ConnectedtoHostIdOrSwitchId; // \n\t\t\n\t\tHost Host1;\n\t\tHost Host2;\n\t\tHost Host3;\n\t\tHost Host4;\n\t\tHost Host5;\n\t\tbyte host1Ip;\n\t\tbyte host2Ip;\n\t\tbyte host3Ip;\n\t\tbyte host4Ip;\n\t\tbyte host5Ip;\n\t\tbyte [10] bufferedPacketeData; \n\t\tbyte packetRepeatCount;\n\t\tboolean packetRepeatedTwice;\n\t\t//boolean IsWaitedForController;\n\t\tboolean isRoutingChanged;\n\t\tboolean isFWError;\n\t} \n   \n\tSwitch(byte switchId, Host connectedHost1, byte connectedHost1Ip, Host connectedHost2, byte connectedHost2Ip , \n\t\t\t\tHost connectedHost3, byte connectedHost3Ip, Host connectedHost4, byte connectedHost4Ip, Host connectedHost5, byte connectedHost5Ip) \n\t{ \n\t    SwId = switchId;\n\t    illegalAccess = false;\n\t    sshProtocolError == false;\n\t\thost1Ip = connectedHost1Ip;\n\t\thost2Ip = connectedHost2Ip;\n\t\thost3Ip = connectedHost3Ip;\n\t\thost4Ip = connectedHost4Ip;\n\t\thost5Ip = connectedHost5Ip;\n\t\tHost1 = connectedHost1;\n\t\tHost2 = connectedHost2;\n\t\tHost3 = connectedHost3;\n\t\tHost4 = connectedHost4;\n\t\tHost5 = connectedHost5;\n\t\t\n\t\t\n\t\tisRoutingChanged = false;\n\t\tisFWError = false;\n\t\tint i; \n     \tfor (i = 0; i < 10; i = i + 1) {\n     \t\tflowTableHeaderDestIP[i] \t= 0;\n     \t\tflowTableHeaderSrcIP[i]\t\t= 0;\n     \t\tflowTableHeaderProtocol[i] \t= 0;\n     \t\tflowTableOutPort[i] \t\t= 0;\n     \t\tflowTableActionType[i] \t\t= 0;\n     \t\t\n     \t}\n     \tpacketRepeatCount \t\t\t\t= 0;\n     \tpacketRepeatedTwice \t\t\t= false;\n     \t//IsWaitedForController \t\t\t= false;\n\n\t}\n\tboolean getMatchFields()\n\t{\n\t}\n\t\n\tboolean sortFlowTable()\n\t{\n\t}\n\t\n\tmsgsrv swHandlePacket(byte packetSrcId , byte packetDestId, byte packetData, byte packetProtocol, byte SwitchPort) \n\t{ // byte header, byte packet, byte protocol\n\t    int i;\n\t    boolean hasRuleInTable;\n\t    hasRuleInTable = false;\n\t    //lookup in flow table \n\t    if ( true) {\n\t\t    for (i = 0; i < 10; i = i + 1) \n\t\t    {\n\t\t    \t//if (hasRuleInTable == true)\n\t\t    \t\t//break; //rules map to action with first match in FlowTable \n\t\t    \tif (flowTableHeaderDestIP[i] == packetDestId \n\t\t    \t&& flowTableHeaderSrcIP[i] == packetSrcId \n\t\t    \t&& flowTableHeaderProtocol[i] == packetProtocol)\n\t\t    \t//if match occured \n\t\t    \t{\n\t\t    \t\thasRuleInTable = true;\n\t\t    \t\tif (flowTableActionType[i] == 1) // drop\n\t\t    \t\t{\n\t\t    \t\t\t//break;\n\t\t\t\t\t} \n\t\t\t\t\telse if (flowTableActionType[i] == 0) //forward\n\t\t\t\t\t{ \n\t\t\t\t\t\tif (SwId == 1) // rules related to switch1\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (packetDestId == host1Ip)\n\t\t    \t\t\t\t{\n\t\t    \t\t\t\t\tHost1.hostHandlePacket(packetSrcId, packetDestId, packetData, packetProtocol, SwitchPort);\n\t\t    \t\t\t\t}\n\t\t    \t\t\t\telse if (packetDestId == host2Ip)\n\t\t    \t\t\t\t{\n\t\t    \t\t\t\t\tHost2.hostHandlePacket(packetSrcId, packetDestId, packetData, packetProtocol, SwitchPort);\n\t\t    \t\t\t\t}\n\t\t    \t\t\t\telse if (packetDestId == host3Ip)\n\t\t    \t\t\t\t{\n\t\t    \t\t\t\t\tHost3.hostHandlePacket(packetSrcId, packetDestId, packetData, packetProtocol, SwitchPort);\n\t\t    \t\t\t\t}\n\t\t    \t\t\t\telse if (packetDestId == host4Ip)\n\t\t    \t\t\t\t{\n\t\t    \t\t\t\t\tHost4.hostHandlePacket(packetSrcId, packetDestId, packetData, packetProtocol, SwitchPort);\n\t\t    \t\t\t\t}\n\t\t    \t\t\t\telse if (packetDestId == host5Ip)\n\t\t    \t\t\t\t{\n\t\t    \t\t\t\t\tHost5.hostHandlePacket(packetSrcId, packetDestId, packetData, packetProtocol, SwitchPort);\n\t\t    \t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t} \n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasRuleInTable == false) // New packet recieved without match in F.T.(Flow Table)\n\t\t{\n\t\t\tcontroller.newPacketInMessage(SwId, packetSrcId , packetDestId, packetData, packetProtocol, SwitchPort);\n\t\t\t//wait for controller response\n\t\t\t//bufferedPacketeData[0] = packetData;\n\t\t\t//IsWaitedForController = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//check if \n\t\t} \n\t}\n\t\n\tmsgsrv changeRouting()\n\t{\n\t\tisRoutingChanged = true;\n\t}\t\n\t\n\tmsgsrv newPacketOutMessage(byte packetSrcId , byte packetDestId, byte packetData, byte packetProtocol, byte SwitchPort, byte action)\n\t{\n\t\n\t\t//This message is sent from the controller to a switch to notify \n\t\t//that it must re-try applying an action rule to a buffered packet. \n\t\t//The message includes the packet header.\n\t\t\n\t\t//insert new rule to flow table\n\t\tboolean ruleIsInserted;\n\t\truleIsInserted = false;\n\t\tint i;\n\t\tfor (i = 0; i < 10; i = i + 1) {\n\t    \tif (ruleIsInserted == false) {\n\t    \t\tif (flowTableHeaderDestIP[i] == 0) {\n\t    \t\t\tflowTableHeaderDestIP[i] \t= packetDestId;\n\t    \t\t\tflowTableHeaderSrcIP[i] \t= packetSrcId;\n\t    \t\t\tflowTableOutPort[i] \t= SwitchPort;\n\t    \t\t\tflowTableHeaderProtocol[i] \t= packetProtocol;\n\t    \t\t\tflowTableActionType[i] \t= action;\n\t    \t\t\truleIsInserted = true;\n\t    \t\t}\n\t    \t}\n\t    }\n\t    \n\t    if (ruleIsInserted == true){\n\t    \tself.swHandlePacket(packetSrcId, packetDestId, packetData , packetProtocol, SwitchPort);\n\t    \t//bufferedPacketeData = 0;\n\t    } \n\t    else \n\t    {\n\t    \t//ERROR\n\t    \t\n\t    }\n\t\t\n\t}\n\t\n\tmsgsrv sendOut(byte packetId)\n\t{\n\t\n\t}\n\t\n\tmsgsrv modifyState(byte packetSrcId , byte packetDestId, byte port, byte action, byte protocol)\n\t{//action 1 = drop & 0 = forward\n\t\t//new action rules to be inserted into the switchÂ’s flow-table\n\t\t//insert new rule to flow table\n\t\tboolean ruleIsInserted;\n\t\truleIsInserted = false;\n\t\tint i;\n\t\tfor (i = 0; i < 10; i = i + 1) {\n\t    \tif (ruleIsInserted == false) {\n\t    \t\tif (flowTableHeaderDestIP[i] == 0 || (flowTableHeaderSrcIP[i] == packetSrcId && flowTableHeaderDestIP[i] == packetDestId && flowTableHeaderProtocol[i] == protocol)) {\n\t    \t\t\tflowTableHeaderDestIP[i] \t\t= packetDestId;\n\t    \t\t\tflowTableHeaderSrcIP[i] \t\t= packetSrcId;\n\t    \t\t\tflowTableOutPort[i] \t\t\t= port;\n\t    \t\t\tflowTableHeaderProtocol[i] \t\t= protocol;\n\t    \t\t\tflowTableActionType[i] \t\t\t= action;\n\t    \t\t\truleIsInserted = true;\n\t    \t\t}\n\t    \t}\n\t    }\n\t   sortFlowTable();\n\t}\n\t\n\tmsgsrv get_Ack(int directionS){\n\t\t\n\t\tboolean [4] outMutex;\n\t\tHost N,E,S,W;\n\n\t\tif (sender == N) {\n\t\t\toutMutex[0] = true;\n\t\t}\t\n\t\telse if (sender == E){ \n\t\t\toutMutex[1] = true;\n\t\t}\t\n\t\telse if (sender == S){\n\t\t\toutMutex[2] = true;\n\t\t\t}\n\t\telse if (sender == W){ \n\t\t\toutMutex[3] = true;\n\t\t}\t\n\t}\n\t\n\tmsgsrv getPermission(int switchId){\n\t\t//((Segment)sender).SwitchEntered(SwitchId);\n\t}\n\n}\n \nreactiveclass Host(17) { \n\tknownrebecs {\n\t\tSwitch knownSwitch;\n \t}\n\tstatevars { \n\t\tbyte id; \n\t\tboolean illegalAccess;\n\t\tboolean sshProtocolError;\n\t\tboolean isRoutingChanged;\n\t\tbyte knownSwitchPort;  \n\t}\n\tHost(byte hostId , byte SwitchPortNumber) { \n\t\tid = hostId;\n\t\tknownSwitchPort = SwitchPortNumber; \n\t\tif (id == 1) { \n\t\t\t// sample package will be send from c1 \n\t\t\t// to destination host indicated by header IP = 10  // protocol 1 = ssh packet\n\n\t\t\t// send from host with ip = 1 to destination host with ip = 3 pachetData =1 with protocol = 0\n\t\t\tself.sendInPacket(1, 3, 1, 0) after(2); //ABS sample\n\t\t\tself.sendInPacket(1, 5, 2, 0) after(2);//ABS sample //host ip = 1 to destination host with ip = 5 , packetData = 2\n\t\t\tself.sendInPacket(1, 4, 6, 0) after(2);//ABS sample\n\t\t\tself.sendInPacket(1, 4, 10, 0) after(2);//ABS sample\n\t\t}\n\t\tif (id == 2) {\n\t\t\tself.sendInPacket(2, 3, 7, 0) after(2);//ABS sample\n\t\t\tself.sendInPacket(2, 5, 8, 0) after(2);//ABS sample\n\t\t\tself.sendInPacket(2, 4, 9, 0) after(2);//ABS sample\n\t\t\tself.sendInPacket(2, 1, 11, 0) after(2);//ABS sample\n\t\t} \n\t\tif (id == 3) {\n\t\t\tself.sendInPacket(3, 2, 3, 0) after(2);//ABS sample\n\t\t} \n\t\tif (id == 4) {\n\t\t\tself.sendInPacket(4, 1, 4, 0) after(2);//ABS sample\n\t\t} \n\t\tif (id == 5) {\n\t\t\tself.sendInPacket(5, 1, 5, 0) after(2);//ABS sample\n\t\t\tself.sendInPacket(5, 1, 12, 0) after(2);//ABS sample\n\t\t\tself.sendInPacket(5, 3, 13, 0) after(2);//My Sample\n\t\t}\n\t\tillegalAccess = false;\n\t\tsshProtocolError = false;\n\t\tisRoutingChanged = false;\n\t} \n\n\tmsgsrv sendInPacket(byte packetSrcId , byte packetDestId, byte packetData, byte packetProtocol) { \n\t\tknownSwitch.swHandlePacket(packetSrcId, packetDestId, packetData, packetProtocol , knownSwitchPort); \n\t}\n\t\n\tmsgsrv hostHandlePacket(byte packetSrcId , byte packetDestId, byte packetData, byte packetProtocol, byte SwitchPort) \n\t{\n\t\t\n\t\tif (id == 1  ) //Hosts in trusted zoon\n\t\t{//packet received in c1,2,3 (trusted hostd)\n\t\t\t//illegalAccess = true;\n\t\t\tif (packetProtocol == 1){\n\t\t\t\tsshProtocolError = true;\n\t\t\t}\n\t\t\t// packetData is = uniqe combination of source and destination for find policy violations\n\t\t\t// this packetData =  packet number must drop because reached from untrusted zoon withoutrequest\n\t\t\tif ( false )//packetData == 4 ||packetData == 5 || packetData == 12)\n\t\t\t{\n\t\t\t\tillegalAccess = true;\n\t\t\t}\n\n\t\t}\n\t\telse if (id == 2 )\n\t\t{\n\t\t\t\t\t\t//illegalAccess = true;\n\t\t\tif (packetProtocol == 1){\n\t\t\t\tsshProtocolError = true;\n\t\t\t}\n\t\t\t// packetData is = uniqe combination of source and destination for find policy violations\n\t\t\t// this packetData =  packet number must drop because reached from untrusted zoon withoutrequest\n\t\t\tif ( packetData == 4 ||packetData == 5 || packetData == 12)\n\t\t\t{\n\t\t\t\tillegalAccess = true;\n\t\t\t}\n\t\t}\n\t\telse if (id == 3)\n\t\t{\n\t\t\tif ( packetData == 13 )// ||packetData == 5 || packetData == 12)\n\t\t\t{\n\t\t\t\tillegalAccess = true;\n\t\t\t}\n\t\t}\n\t\telse if (id >= 4)\n\t\t{\n\t\t\t//illegalAccess = true;\n\t\t}\n\t\tif (packetData == 1 || id == 3) //for check all state without deadlock\n\t\t\tself.done() after(100);\n\t}\n\t\n\tmsgsrv done() {\n\t\tself.done() after(100);\n\t}\n\t\n}\n\n\nmain { \n\t\n\tController controller(s1):(); \n   \t\n   \t//Switch has 2 port ={0,1} \n   \t//trusted host connected to port 1 and untrusted hosts connected to port 2 \n   \t//parameters ordered = switchId , 5 pair of ( host and id )\n   \t//mission is prevent packets reach from untrusted host to trusted hosts without request from trusted hosts.\n\tSwitch s1(controller):(1, c1, 1, c2, 2 , c3, 3, c4, 4, c5 , 5); \n \n \n\tHost c1(s1):(1,1); // connect host c1 to switch s1 by id = 1 to port = 1 of switch\n\tHost c2(s1):(2,1); // connect host c2 to switch s1 by id = 2 to port = 1 of switch\n\tHost c3(s1):(3,1); // connect host c3 to switch s1 by id = 3 to port = 1 of switch\n\tHost c4(s1):(4,2); // connect host c4 to switch s1 by id = 4 to port = 2 of switch\n\tHost c5(s1):(5,2); // connect host c5 to switch s1 by id = 5 to port = 2 of switch\n   \n\t// Topology:\n\t//\t\t\t\t\t\t\t\t\t\t\t[controller]\n\t//\t\t\t\t\t\t\t\t\t\t\t\t  |\n\t//\t[Computer 1]   [Computer 2]  [Computer 3]-p1-[Switchrouter] -p2- internet -- [Computer 4]\n    //\t\t|              |                         |  |\t\t\t\t  |\n    //\t\t|              +-------------------------p1 |\t\t\t\t  |\n    //\t\t|                                           | \t\t\t\t  +------[computer 5]\n    //\t\t+-------------------------------------------p1\n}\n\n\n","colorizedLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":null,"configFilePath":null,"networkDependabotPath":"/h-zeynali/Rebeca/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":false,"repoAlertsPath":"/h-zeynali/Rebeca/security/dependabot","repoSecurityAndAnalysisPath":"/h-zeynali/Rebeca/settings/security_analysis","repoOwnerIsOrg":false,"currentUserCanAdminRepo":true},"displayName":"Naive_FireWall_1S_5H_13P.rebeca","displayUrl":"https://github.com/h-zeynali/Rebeca/blob/main/SDN/Naive_FireWall_1S_5H_13P.rebeca?raw=true","headerInfo":{"blobSize":"13.2 KB","deleteInfo":{"deletePath":"https://github.com/h-zeynali/Rebeca/delete/main/SDN/Naive_FireWall_1S_5H_13P.rebeca","deleteTooltip":"Delete this file"},"editInfo":{"editTooltip":"Edit this file"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"e62a4b5","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Fh-zeynali%2FRebeca%2Fblob%2Fmain%2FSDN%2FNaive_FireWall_1S_5H_13P.rebeca","isCSV":false,"isRichtext":false,"toc":null,"lineInfo":{"truncatedLoc":"474","truncatedSloc":"411"},"mode":"file"},"image":false,"isCodeownersFile":null,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":null,"large":false,"loggedIn":true,"newDiscussionPath":"/h-zeynali/Rebeca/discussions/new","newIssuePath":"/h-zeynali/Rebeca/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/h-zeynali/Rebeca/blob/main/SDN/Naive_FireWall_1S_5H_13P.rebeca","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/h-zeynali/Rebeca/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":null,"renderedFileInfo":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"h-zeynali","repoName":"Rebeca","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":null,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":false,"symbols":[]}},"csrf_tokens":{"/h-zeynali/Rebeca/branches":{"post":"7CkSletW6Bem20KOvzjx3-GVYFpbnpssO5D5vK0uaRygR7twt-DRLERJh-KGHruGSJAzasGoX6AH8bEVzvlQwg"}}},"title":"Rebeca/Naive_FireWall_1S_5H_13P.rebeca at main · h-zeynali/Rebeca","locale":"en"}